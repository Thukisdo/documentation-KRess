<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Kreps: math::clFTensor Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Kreps
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
   <div id="projectbrief">Breast cancer detection through machine learning</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classmath_1_1cl_f_tensor.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classmath_1_1cl_f_tensor-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">math::clFTensor Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Represents a tensor of <a class="el" href="classmath_1_1cl_f_matrix.html" title="A float matrix stored in a cl::Buffer. Provides wrappers for most clblast operations.">clFMatrix</a>. Each matrix is of size x * y, the z dimension is the number of matrices.  
 <a href="classmath_1_1cl_f_tensor.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="cl_f_tensor_8hpp_source.html">clFTensor.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af20a6bf3e247e5a7bcf9dcc689dc235b"><td class="memItemLeft" align="right" valign="top"><a id="af20a6bf3e247e5a7bcf9dcc689dc235b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>clFTensor</b> (size_t width, size_t height, size_t depth)</td></tr>
<tr class="separator:af20a6bf3e247e5a7bcf9dcc689dc235b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a735d9570546f7da3386b9fdf2c4d8f53"><td class="memItemLeft" align="right" valign="top"><a id="a735d9570546f7da3386b9fdf2c4d8f53"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>clFTensor</b> (const <a class="el" href="classmath_1_1cl_f_tensor.html">clFTensor</a> &amp;other, cl::CommandQueue &amp;queue, bool blocking)</td></tr>
<tr class="separator:a735d9570546f7da3386b9fdf2c4d8f53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a302c3542b8d871edd1666f5cacc96203"><td class="memItemLeft" align="right" valign="top"><a id="a302c3542b8d871edd1666f5cacc96203"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>clFTensor</b> (const <a class="el" href="classmath_1_1cl_f_tensor.html">clFTensor</a> &amp;other, bool blocking)</td></tr>
<tr class="separator:a302c3542b8d871edd1666f5cacc96203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66e7f333b039a0931f1ec140a5bb22b9"><td class="memItemLeft" align="right" valign="top"><a id="a66e7f333b039a0931f1ec140a5bb22b9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>clFTensor</b> (const <a class="el" href="classmath_1_1cl_f_tensor.html">clFTensor</a> &amp;other)=delete</td></tr>
<tr class="separator:a66e7f333b039a0931f1ec140a5bb22b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9988f1650ba4e208ea74fee6fb9f8223"><td class="memItemLeft" align="right" valign="top"><a id="a9988f1650ba4e208ea74fee6fb9f8223"></a>
<a class="el" href="classmath_1_1cl_f_tensor.html">clFTensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classmath_1_1cl_f_tensor.html">clFTensor</a> &amp;other)=delete</td></tr>
<tr class="separator:a9988f1650ba4e208ea74fee6fb9f8223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa31169755f7c6347343deab894c3bf9b"><td class="memItemLeft" align="right" valign="top"><a id="aa31169755f7c6347343deab894c3bf9b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>clFTensor</b> (<a class="el" href="classmath_1_1cl_f_tensor.html">clFTensor</a> &amp;&amp;other)=default</td></tr>
<tr class="separator:aa31169755f7c6347343deab894c3bf9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1122896f3664c600a15b7673bfb4370"><td class="memItemLeft" align="right" valign="top"><a id="ad1122896f3664c600a15b7673bfb4370"></a>
<a class="el" href="classmath_1_1cl_f_tensor.html">clFTensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classmath_1_1cl_f_tensor.html">clFTensor</a> &amp;&amp;other)=default</td></tr>
<tr class="separator:ad1122896f3664c600a15b7673bfb4370"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60226acd30f01d8f90762328438ab6ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmath_1_1cl_f_tensor.html">clFTensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmath_1_1cl_f_tensor.html#a60226acd30f01d8f90762328438ab6ed">copy</a> (const <a class="el" href="classmath_1_1cl_f_tensor.html">clFTensor</a> &amp;other, cl::CommandQueue &amp;queue, bool blocking)</td></tr>
<tr class="memdesc:a60226acd30f01d8f90762328438ab6ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a deep copy of the tensor.  <a href="classmath_1_1cl_f_tensor.html#a60226acd30f01d8f90762328438ab6ed">More...</a><br /></td></tr>
<tr class="separator:a60226acd30f01d8f90762328438ab6ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a215201957ad7dae884cc2bea931c4bbb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmath_1_1cl_f_tensor.html">clFTensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmath_1_1cl_f_tensor.html#a215201957ad7dae884cc2bea931c4bbb">shallowCopy</a> () const</td></tr>
<tr class="memdesc:a215201957ad7dae884cc2bea931c4bbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a shallow copy of this tensor, meaning that the new tensor shares the same data. Any changes to the data of the new tensor will also affect the data of this tensor.  <a href="classmath_1_1cl_f_tensor.html#a215201957ad7dae884cc2bea931c4bbb">More...</a><br /></td></tr>
<tr class="separator:a215201957ad7dae884cc2bea931c4bbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7db2f1cdd9cac39ef4518b66b84bd5c9"><td class="memItemLeft" align="right" valign="top"><a id="a7db2f1cdd9cac39ef4518b66b84bd5c9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>fill</b> (float elem, cl::CommandQueue &amp;queue, bool blocking)</td></tr>
<tr class="separator:a7db2f1cdd9cac39ef4518b66b84bd5c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0f97d8bba1b9ec670de2907608fca61"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classmath_1_1cl_f_tensor.html">clFTensor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmath_1_1cl_f_tensor.html#ac0f97d8bba1b9ec670de2907608fca61">slice</a> (size_t ndiv) const</td></tr>
<tr class="memdesc:ac0f97d8bba1b9ec670de2907608fca61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides the tensor into multiple chunks.  <a href="classmath_1_1cl_f_tensor.html#ac0f97d8bba1b9ec670de2907608fca61">More...</a><br /></td></tr>
<tr class="separator:ac0f97d8bba1b9ec670de2907608fca61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a827078394c2c42011e52e35e533cf56a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmath_1_1cl_f_tensor.html">clFTensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmath_1_1cl_f_tensor.html#a827078394c2c42011e52e35e533cf56a">slice</a> (size_t begin, size_t end) const</td></tr>
<tr class="memdesc:a827078394c2c42011e52e35e533cf56a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Slice this tensor and return the tensor(rows, cols, begin:end)  <a href="classmath_1_1cl_f_tensor.html#a827078394c2c42011e52e35e533cf56a">More...</a><br /></td></tr>
<tr class="separator:a827078394c2c42011e52e35e533cf56a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a282cb50a1cb9fd8768fd987e4d2642fe"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmath_1_1cl_f_tensor.html#a282cb50a1cb9fd8768fd987e4d2642fe">getOffsetOf</a> (size_t matrix_index) const</td></tr>
<tr class="memdesc:a282cb50a1cb9fd8768fd987e4d2642fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the offset in floats of the matrix at the given index.  <a href="classmath_1_1cl_f_tensor.html#a282cb50a1cb9fd8768fd987e4d2642fe">More...</a><br /></td></tr>
<tr class="separator:a282cb50a1cb9fd8768fd987e4d2642fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b58a519a86a701da759504c978840a2"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmath_1_1cl_f_tensor.html#a1b58a519a86a701da759504c978840a2">getOffsetOfInBytes</a> (size_t matrix_index) const</td></tr>
<tr class="memdesc:a1b58a519a86a701da759504c978840a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the offset in bytes of the matrix at the given index.  <a href="classmath_1_1cl_f_tensor.html#a1b58a519a86a701da759504c978840a2">More...</a><br /></td></tr>
<tr class="separator:a1b58a519a86a701da759504c978840a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeec7e4ee469c07b70be36dfbd51faea6"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmath_1_1cl_f_tensor.html#aeec7e4ee469c07b70be36dfbd51faea6">getOffset</a> () const</td></tr>
<tr class="memdesc:aeec7e4ee469c07b70be36dfbd51faea6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the offset in matrix of this tensor.  <a href="classmath_1_1cl_f_tensor.html#aeec7e4ee469c07b70be36dfbd51faea6">More...</a><br /></td></tr>
<tr class="separator:aeec7e4ee469c07b70be36dfbd51faea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30b7b98ad4e3ec4f88927485ff0a5fe0"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmath_1_1cl_f_tensor.html#a30b7b98ad4e3ec4f88927485ff0a5fe0">getOffsetInBytes</a> () const</td></tr>
<tr class="memdesc:a30b7b98ad4e3ec4f88927485ff0a5fe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the offset in bytes of this tensor.  <a href="classmath_1_1cl_f_tensor.html#a30b7b98ad4e3ec4f88927485ff0a5fe0">More...</a><br /></td></tr>
<tr class="separator:a30b7b98ad4e3ec4f88927485ff0a5fe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b169c90d12414c23f11d39433685c4f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmath_1_1cl_f_tensor.html#a0b169c90d12414c23f11d39433685c4f">getOffsetInFloats</a> () const</td></tr>
<tr class="memdesc:a0b169c90d12414c23f11d39433685c4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the offsets in floats of this tensor.  <a href="classmath_1_1cl_f_tensor.html#a0b169c90d12414c23f11d39433685c4f">More...</a><br /></td></tr>
<tr class="separator:a0b169c90d12414c23f11d39433685c4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a73415a132d9c00a75bedd4856cb939"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmath_1_1cl_f_tensor.html">clFTensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmath_1_1cl_f_tensor.html#a0a73415a132d9c00a75bedd4856cb939">flatten</a> () const</td></tr>
<tr class="memdesc:a0a73415a132d9c00a75bedd4856cb939"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classmath_1_1cl_f_tensor.html" title="Represents a tensor of clFMatrix. Each matrix is of size x * y, the z dimension is the number of matr...">clFTensor</a> wheres matrices are flattened (x * y, 1, z) Beware that this operation does not copy the matrices, and any change to the matrices will be reflected in the original <a class="el" href="classmath_1_1cl_f_tensor.html" title="Represents a tensor of clFMatrix. Each matrix is of size x * y, the z dimension is the number of matr...">clFTensor</a>.  <a href="classmath_1_1cl_f_tensor.html#a0a73415a132d9c00a75bedd4856cb939">More...</a><br /></td></tr>
<tr class="separator:a0a73415a132d9c00a75bedd4856cb939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba6aa8b404966ceb0428bde0b514c99b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmath_1_1cl_f_matrix.html">clFMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmath_1_1cl_f_tensor.html#aba6aa8b404966ceb0428bde0b514c99b">getMatrix</a> (size_t z)</td></tr>
<tr class="memdesc:aba6aa8b404966ceb0428bde0b514c99b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the submatrix at the given index. Note that the returned matrix is a view of the internal matrix, and any change made to it will be reflected in the tensor.  <a href="classmath_1_1cl_f_tensor.html#aba6aa8b404966ceb0428bde0b514c99b">More...</a><br /></td></tr>
<tr class="separator:aba6aa8b404966ceb0428bde0b514c99b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae722b88dd9ca6e470e20b4c9a304a7f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmath_1_1cl_f_matrix.html">clFMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmath_1_1cl_f_tensor.html#ae722b88dd9ca6e470e20b4c9a304a7f3">getMatrix</a> (size_t z) const</td></tr>
<tr class="memdesc:ae722b88dd9ca6e470e20b4c9a304a7f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the submatrix at the given index. Note that the returned matrix is a view of the internal matrix, and any change made to it will be reflected in the tensor.  <a href="classmath_1_1cl_f_tensor.html#ae722b88dd9ca6e470e20b4c9a304a7f3">More...</a><br /></td></tr>
<tr class="separator:ae722b88dd9ca6e470e20b4c9a304a7f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f4926ccefb975adc932ce74b9d20843"><td class="memItemLeft" align="right" valign="top"><a id="a0f4926ccefb975adc932ce74b9d20843"></a>
<a class="el" href="classmath_1_1cl_f_matrix.html">clFMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator[]</b> (size_t z)</td></tr>
<tr class="separator:a0f4926ccefb975adc932ce74b9d20843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a132ad15b8943ab7eed6f0981dace2f4a"><td class="memItemLeft" align="right" valign="top"><a id="a132ad15b8943ab7eed6f0981dace2f4a"></a>
<a class="el" href="classmath_1_1cl_f_matrix.html">clFMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator[]</b> (size_t z) const</td></tr>
<tr class="separator:a132ad15b8943ab7eed6f0981dace2f4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad798ffd88d7c128e8602c0cd862e949c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classmath_1_1cl_f_matrix.html">clFMatrix</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmath_1_1cl_f_tensor.html#ad798ffd88d7c128e8602c0cd862e949c">getMatrices</a> ()</td></tr>
<tr class="memdesc:ad798ffd88d7c128e8602c0cd862e949c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an array of submatrices.  <a href="classmath_1_1cl_f_tensor.html#ad798ffd88d7c128e8602c0cd862e949c">More...</a><br /></td></tr>
<tr class="separator:ad798ffd88d7c128e8602c0cd862e949c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87c5fc84fc104dc5b56c2641e39abb36"><td class="memItemLeft" align="right" valign="top"><a id="a87c5fc84fc104dc5b56c2641e39abb36"></a>
std::vector&lt; <a class="el" href="classmath_1_1cl_f_matrix.html">clFMatrix</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getMatrices</b> () const</td></tr>
<tr class="separator:a87c5fc84fc104dc5b56c2641e39abb36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a580acecfa45c13a82e6bee47f4ff213f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmath_1_1cl_f_tensor.html#a580acecfa45c13a82e6bee47f4ff213f">getRows</a> () const</td></tr>
<tr class="memdesc:a580acecfa45c13a82e6bee47f4ff213f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the x dimension of the tensor, corresponding to the number of columns in each matrix.  <a href="classmath_1_1cl_f_tensor.html#a580acecfa45c13a82e6bee47f4ff213f">More...</a><br /></td></tr>
<tr class="separator:a580acecfa45c13a82e6bee47f4ff213f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afef17ecdcf0f08ed9c5c5fe4bbe39d85"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmath_1_1cl_f_tensor.html#afef17ecdcf0f08ed9c5c5fe4bbe39d85">getCols</a> () const</td></tr>
<tr class="memdesc:afef17ecdcf0f08ed9c5c5fe4bbe39d85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the y dimension of the tensor, corresponding to the number of rows in each matrix.  <a href="classmath_1_1cl_f_tensor.html#afef17ecdcf0f08ed9c5c5fe4bbe39d85">More...</a><br /></td></tr>
<tr class="separator:afef17ecdcf0f08ed9c5c5fe4bbe39d85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f8dc79999cc7a32207d42f01075e351"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmath_1_1cl_f_tensor.html#a7f8dc79999cc7a32207d42f01075e351">getDepth</a> () const</td></tr>
<tr class="memdesc:a7f8dc79999cc7a32207d42f01075e351"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the z dimension of the tensor, corresponding to the number of matrices.  <a href="classmath_1_1cl_f_tensor.html#a7f8dc79999cc7a32207d42f01075e351">More...</a><br /></td></tr>
<tr class="separator:a7f8dc79999cc7a32207d42f01075e351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaf9bad16c04bb7ad1b31aebf748d989"><td class="memItemLeft" align="right" valign="top"><a id="acaf9bad16c04bb7ad1b31aebf748d989"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>size</b> () const</td></tr>
<tr class="separator:acaf9bad16c04bb7ad1b31aebf748d989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33f5112a24b0bb99bbc07390ec14f9f1"><td class="memItemLeft" align="right" valign="top"><a id="a33f5112a24b0bb99bbc07390ec14f9f1"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>sizeInBytes</b> () const</td></tr>
<tr class="separator:a33f5112a24b0bb99bbc07390ec14f9f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9c36ed2160f9e6a4e44430e6eafaebe"><td class="memItemLeft" align="right" valign="top">cl::Buffer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmath_1_1cl_f_tensor.html#ae9c36ed2160f9e6a4e44430e6eafaebe">getBuffer</a> () const</td></tr>
<tr class="memdesc:ae9c36ed2160f9e6a4e44430e6eafaebe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the opencl buffer associated with the tensor.  <a href="classmath_1_1cl_f_tensor.html#ae9c36ed2160f9e6a4e44430e6eafaebe">More...</a><br /></td></tr>
<tr class="separator:ae9c36ed2160f9e6a4e44430e6eafaebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb198043705a658795940854fc76a2f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmath_1_1cl_f_tensor.html#acb198043705a658795940854fc76a2f2">reshape</a> (size_t new_rows, size_t new_cols, size_t new_depth)</td></tr>
<tr class="memdesc:acb198043705a658795940854fc76a2f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reshapes the tensor to the given dimensions.  <a href="classmath_1_1cl_f_tensor.html#acb198043705a658795940854fc76a2f2">More...</a><br /></td></tr>
<tr class="separator:acb198043705a658795940854fc76a2f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8ef0a5164d96502e9b018f3163309e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmath_1_1cl_f_tensor.html">clFTensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmath_1_1cl_f_tensor.html#aa8ef0a5164d96502e9b018f3163309e4">sub</a> (float alpha, const <a class="el" href="classmath_1_1cl_f_tensor.html">clFTensor</a> &amp;other, cl::CommandQueue &amp;queue, bool blocking=false) const</td></tr>
<tr class="memdesc:aa8ef0a5164d96502e9b018f3163309e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">C = A - alpha * B.  <a href="classmath_1_1cl_f_tensor.html#aa8ef0a5164d96502e9b018f3163309e4">More...</a><br /></td></tr>
<tr class="separator:aa8ef0a5164d96502e9b018f3163309e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad748b6faa89aa1e8ca7aeef9f6573de3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmath_1_1cl_f_tensor.html#ad748b6faa89aa1e8ca7aeef9f6573de3">ipadd</a> (float alpha, const <a class="el" href="classmath_1_1cl_f_tensor.html">clFTensor</a> &amp;B, cl::CommandQueue &amp;queue, bool blocking=false)</td></tr>
<tr class="memdesc:ad748b6faa89aa1e8ca7aeef9f6573de3"><td class="mdescLeft">&#160;</td><td class="mdescRight">C = C + alpha * B, where B is a tensor.  <a href="classmath_1_1cl_f_tensor.html#ad748b6faa89aa1e8ca7aeef9f6573de3">More...</a><br /></td></tr>
<tr class="separator:ad748b6faa89aa1e8ca7aeef9f6573de3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6a0118b0b5a8d41bbac42cf23d16cfe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmath_1_1cl_f_matrix.html">clFMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmath_1_1cl_f_tensor.html#ae6a0118b0b5a8d41bbac42cf23d16cfe">sumCollapse</a> (cl::CommandQueue &amp;queue, bool blocking=false) const</td></tr>
<tr class="memdesc:ae6a0118b0b5a8d41bbac42cf23d16cfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sums the tensors along the z-axis, returning a single matrix.  <a href="classmath_1_1cl_f_tensor.html#ae6a0118b0b5a8d41bbac42cf23d16cfe">More...</a><br /></td></tr>
<tr class="separator:ae6a0118b0b5a8d41bbac42cf23d16cfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ba6f7edcf31419499c5168bf68d4fa5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmath_1_1cl_f_tensor.html">clFTensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmath_1_1cl_f_tensor.html#a0ba6f7edcf31419499c5168bf68d4fa5">iphadamard</a> (const <a class="el" href="classmath_1_1cl_f_tensor.html">clFTensor</a> &amp;other, cl::CommandQueue &amp;queue, bool blocking=false)</td></tr>
<tr class="memdesc:a0ba6f7edcf31419499c5168bf68d4fa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply two tensors element by element.  <a href="classmath_1_1cl_f_tensor.html#a0ba6f7edcf31419499c5168bf68d4fa5">More...</a><br /></td></tr>
<tr class="separator:a0ba6f7edcf31419499c5168bf68d4fa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5b4d1b6dc55f7d3f640793b822d2cb4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmath_1_1cl_f_tensor.html#ab5b4d1b6dc55f7d3f640793b822d2cb4">ipscale</a> (float factor, cl::CommandQueue &amp;queue, bool blocking=false)</td></tr>
<tr class="memdesc:ab5b4d1b6dc55f7d3f640793b822d2cb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inplace Scale every element of the tensor by a factor.  <a href="classmath_1_1cl_f_tensor.html#ab5b4d1b6dc55f7d3f640793b822d2cb4">More...</a><br /></td></tr>
<tr class="separator:ab5b4d1b6dc55f7d3f640793b822d2cb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a93e860fbb896a52eefd4961e82aa5186"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmath_1_1cl_f_tensor.html">clFTensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmath_1_1cl_f_tensor.html#a93e860fbb896a52eefd4961e82aa5186">batchedGemm</a> (float alpha, bool transpose_a, const <a class="el" href="classmath_1_1cl_f_matrix.html">clFMatrix</a> &amp;A, bool transpose_b, const <a class="el" href="classmath_1_1cl_f_tensor.html">clFTensor</a> &amp;B, cl::CommandQueue &amp;queue, bool blocking=false)</td></tr>
<tr class="memdesc:a93e860fbb896a52eefd4961e82aa5186"><td class="mdescLeft">&#160;</td><td class="mdescRight">C = alpha * A * B, where A is a matrix and B is a tensor.  <a href="classmath_1_1cl_f_tensor.html#a93e860fbb896a52eefd4961e82aa5186">More...</a><br /></td></tr>
<tr class="separator:a93e860fbb896a52eefd4961e82aa5186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf2870c501197ef9c45497dc7b957a7a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmath_1_1cl_f_tensor.html">clFTensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmath_1_1cl_f_tensor.html#abf2870c501197ef9c45497dc7b957a7a">batchedGemm</a> (float alpha, bool transpose_a, const <a class="el" href="classmath_1_1cl_f_matrix.html">clFMatrix</a> &amp;A, bool transpose_b, const <a class="el" href="classmath_1_1cl_f_tensor.html">clFTensor</a> &amp;B, float beta, const <a class="el" href="classmath_1_1cl_f_matrix.html">clFMatrix</a> &amp;C, cl::CommandQueue &amp;queue, bool blocking=false)</td></tr>
<tr class="memdesc:abf2870c501197ef9c45497dc7b957a7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">R = alpha * A * B + beta * C, where A is a matrix, B a tensor, and C a matrix.  <a href="classmath_1_1cl_f_tensor.html#abf2870c501197ef9c45497dc7b957a7a">More...</a><br /></td></tr>
<tr class="separator:abf2870c501197ef9c45497dc7b957a7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f0741aba8a6d3d867e9238f749735ec"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmath_1_1cl_f_tensor.html">clFTensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmath_1_1cl_f_tensor.html#a3f0741aba8a6d3d867e9238f749735ec">batchedGemm</a> (float alpha, bool transpose_a, const <a class="el" href="classmath_1_1cl_f_tensor.html">clFTensor</a> &amp;A, bool transpose_b, const <a class="el" href="classmath_1_1cl_f_tensor.html">clFTensor</a> &amp;B, cl::CommandQueue &amp;queue, bool blocking=false)</td></tr>
<tr class="memdesc:a3f0741aba8a6d3d867e9238f749735ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">C = alpha * A * B, where A and B are tensors.  <a href="classmath_1_1cl_f_tensor.html#a3f0741aba8a6d3d867e9238f749735ec">More...</a><br /></td></tr>
<tr class="separator:a3f0741aba8a6d3d867e9238f749735ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ac73422a8b50d8c690165955f0dc6b06d"><td class="memItemLeft" align="right" valign="top"><a id="ac73422a8b50d8c690165955f0dc6b06d"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="classmath_1_1cl_f_tensor.html">clFTensor</a> &amp;t)</td></tr>
<tr class="separator:ac73422a8b50d8c690165955f0dc6b06d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents a tensor of <a class="el" href="classmath_1_1cl_f_matrix.html" title="A float matrix stored in a cl::Buffer. Provides wrappers for most clblast operations.">clFMatrix</a>. Each matrix is of size x * y, the z dimension is the number of matrices. </p>
<p>This class can be used for efficient batched matrix multiplication. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a93e860fbb896a52eefd4961e82aa5186"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93e860fbb896a52eefd4961e82aa5186">&#9670;&nbsp;</a></span>batchedGemm() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmath_1_1cl_f_tensor.html">clFTensor</a> math::clFTensor::batchedGemm </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>transpose_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmath_1_1cl_f_matrix.html">clFMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>transpose_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmath_1_1cl_f_tensor.html">clFTensor</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::CommandQueue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blocking</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>C = alpha * A * B, where A is a matrix and B is a tensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td></td></tr>
    <tr><td class="paramname">transpose_a</td><td>If true transposes A </td></tr>
    <tr><td class="paramname">A</td><td></td></tr>
    <tr><td class="paramname">transpose_b</td><td>If true transposes B </td></tr>
    <tr><td class="paramname">B</td><td></td></tr>
    <tr><td class="paramname">queue</td><td></td></tr>
    <tr><td class="paramname">blocking</td><td>If true, blocks until the operation is complete </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="abf2870c501197ef9c45497dc7b957a7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf2870c501197ef9c45497dc7b957a7a">&#9670;&nbsp;</a></span>batchedGemm() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmath_1_1cl_f_tensor.html">clFTensor</a> math::clFTensor::batchedGemm </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>transpose_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmath_1_1cl_f_matrix.html">clFMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>transpose_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmath_1_1cl_f_tensor.html">clFTensor</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmath_1_1cl_f_matrix.html">clFMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::CommandQueue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blocking</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>R = alpha * A * B + beta * C, where A is a matrix, B a tensor, and C a matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td></td></tr>
    <tr><td class="paramname">transpose_a</td><td>If true transposes A </td></tr>
    <tr><td class="paramname">A</td><td></td></tr>
    <tr><td class="paramname">transpose_b</td><td>If true transposes B </td></tr>
    <tr><td class="paramname">B</td><td></td></tr>
    <tr><td class="paramname">beta</td><td></td></tr>
    <tr><td class="paramname">C</td><td></td></tr>
    <tr><td class="paramname">queue</td><td></td></tr>
    <tr><td class="paramname">blocking</td><td>If true, blocks until the operation is complete </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a3f0741aba8a6d3d867e9238f749735ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f0741aba8a6d3d867e9238f749735ec">&#9670;&nbsp;</a></span>batchedGemm() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmath_1_1cl_f_tensor.html">clFTensor</a> math::clFTensor::batchedGemm </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>transpose_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmath_1_1cl_f_tensor.html">clFTensor</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>transpose_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmath_1_1cl_f_tensor.html">clFTensor</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::CommandQueue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blocking</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>C = alpha * A * B, where A and B are tensors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td></td></tr>
    <tr><td class="paramname">transpose_a</td><td>If true transposes A </td></tr>
    <tr><td class="paramname">A</td><td></td></tr>
    <tr><td class="paramname">transpose_b</td><td>If true transposes B </td></tr>
    <tr><td class="paramname">B</td><td></td></tr>
    <tr><td class="paramname">queue</td><td></td></tr>
    <tr><td class="paramname">blocking</td><td>If true, blocks until the operation is complete </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a60226acd30f01d8f90762328438ab6ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60226acd30f01d8f90762328438ab6ed">&#9670;&nbsp;</a></span>copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmath_1_1cl_f_tensor.html">clFTensor</a> &amp; math::clFTensor::copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmath_1_1cl_f_tensor.html">clFTensor</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::CommandQueue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blocking</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a deep copy of the tensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>The queue to use for the copy. </td></tr>
    <tr><td class="paramname">blocking</td><td>If true, the operation will block until the copy is finished. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new tensor with a copy of the data of this tensor </dd></dl>

</div>
</div>
<a id="a0a73415a132d9c00a75bedd4856cb939"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a73415a132d9c00a75bedd4856cb939">&#9670;&nbsp;</a></span>flatten()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmath_1_1cl_f_tensor.html">clFTensor</a> math::clFTensor::flatten </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="classmath_1_1cl_f_tensor.html" title="Represents a tensor of clFMatrix. Each matrix is of size x * y, the z dimension is the number of matr...">clFTensor</a> wheres matrices are flattened (x * y, 1, z) Beware that this operation does not copy the matrices, and any change to the matrices will be reflected in the original <a class="el" href="classmath_1_1cl_f_tensor.html" title="Represents a tensor of clFMatrix. Each matrix is of size x * y, the z dimension is the number of matr...">clFTensor</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="ae9c36ed2160f9e6a4e44430e6eafaebe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9c36ed2160f9e6a4e44430e6eafaebe">&#9670;&nbsp;</a></span>getBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cl::Buffer math::clFTensor::getBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the opencl buffer associated with the tensor. </p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="afef17ecdcf0f08ed9c5c5fe4bbe39d85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afef17ecdcf0f08ed9c5c5fe4bbe39d85">&#9670;&nbsp;</a></span>getCols()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t math::clFTensor::getCols </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the y dimension of the tensor, corresponding to the number of rows in each matrix. </p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a7f8dc79999cc7a32207d42f01075e351"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f8dc79999cc7a32207d42f01075e351">&#9670;&nbsp;</a></span>getDepth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t math::clFTensor::getDepth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the z dimension of the tensor, corresponding to the number of matrices. </p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="ad798ffd88d7c128e8602c0cd862e949c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad798ffd88d7c128e8602c0cd862e949c">&#9670;&nbsp;</a></span>getMatrices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classmath_1_1cl_f_matrix.html">clFMatrix</a> &gt; math::clFTensor::getMatrices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an array of submatrices. </p>
<ul>
<li>Submatrices created this way remains valid even if the tensor is destroyed, since openCl keeps track of buffers and subbuffers. <dl class="section return"><dt>Returns</dt><dd>An array of submatrices inside the tensor </dd></dl>
</li>
</ul>

</div>
</div>
<a id="aba6aa8b404966ceb0428bde0b514c99b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba6aa8b404966ceb0428bde0b514c99b">&#9670;&nbsp;</a></span>getMatrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmath_1_1cl_f_matrix.html">clFMatrix</a> math::clFTensor::getMatrix </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the submatrix at the given index. Note that the returned matrix is a view of the internal matrix, and any change made to it will be reflected in the tensor. </p>
<p>Submatrices created this way remains valid even if the tensor is destroyed, since openCl keeps track of buffers and subbuffers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>The index of the submatrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A submatrix inside the tensor, throws on error </dd></dl>

</div>
</div>
<a id="ae722b88dd9ca6e470e20b4c9a304a7f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae722b88dd9ca6e470e20b4c9a304a7f3">&#9670;&nbsp;</a></span>getMatrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmath_1_1cl_f_matrix.html">clFMatrix</a> math::clFTensor::getMatrix </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the submatrix at the given index. Note that the returned matrix is a view of the internal matrix, and any change made to it will be reflected in the tensor. </p>
<p>Submatrices created this way remains valid even if the tensor is destroyed, since openCl keeps track of buffers and subbuffers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>The index of the submatrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A submatrix inside the tensor, throws on error </dd></dl>

</div>
</div>
<a id="aeec7e4ee469c07b70be36dfbd51faea6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeec7e4ee469c07b70be36dfbd51faea6">&#9670;&nbsp;</a></span>getOffset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t math::clFTensor::getOffset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the offset in matrix of this tensor. </p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a30b7b98ad4e3ec4f88927485ff0a5fe0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30b7b98ad4e3ec4f88927485ff0a5fe0">&#9670;&nbsp;</a></span>getOffsetInBytes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t math::clFTensor::getOffsetInBytes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the offset in bytes of this tensor. </p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a0b169c90d12414c23f11d39433685c4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b169c90d12414c23f11d39433685c4f">&#9670;&nbsp;</a></span>getOffsetInFloats()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t math::clFTensor::getOffsetInFloats </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the offsets in floats of this tensor. </p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a282cb50a1cb9fd8768fd987e4d2642fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a282cb50a1cb9fd8768fd987e4d2642fe">&#9670;&nbsp;</a></span>getOffsetOf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t math::clFTensor::getOffsetOf </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>matrix_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the offset in floats of the matrix at the given index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix_index</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a1b58a519a86a701da759504c978840a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b58a519a86a701da759504c978840a2">&#9670;&nbsp;</a></span>getOffsetOfInBytes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t math::clFTensor::getOffsetOfInBytes </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>matrix_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the offset in bytes of the matrix at the given index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a580acecfa45c13a82e6bee47f4ff213f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a580acecfa45c13a82e6bee47f4ff213f">&#9670;&nbsp;</a></span>getRows()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t math::clFTensor::getRows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the x dimension of the tensor, corresponding to the number of columns in each matrix. </p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="ad748b6faa89aa1e8ca7aeef9f6573de3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad748b6faa89aa1e8ca7aeef9f6573de3">&#9670;&nbsp;</a></span>ipadd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void math::clFTensor::ipadd </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmath_1_1cl_f_tensor.html">clFTensor</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::CommandQueue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blocking</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>C = C + alpha * B, where B is a tensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td></td></tr>
    <tr><td class="paramname">B</td><td></td></tr>
    <tr><td class="paramname">queue</td><td></td></tr>
    <tr><td class="paramname">blocking</td><td>If true, blocks until the operation is complete </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0ba6f7edcf31419499c5168bf68d4fa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ba6f7edcf31419499c5168bf68d4fa5">&#9670;&nbsp;</a></span>iphadamard()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmath_1_1cl_f_tensor.html">clFTensor</a> &amp; math::clFTensor::iphadamard </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmath_1_1cl_f_tensor.html">clFTensor</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::CommandQueue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blocking</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply two tensors element by element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td></td></tr>
    <tr><td class="paramname">queue</td><td></td></tr>
    <tr><td class="paramname">blocking</td><td>If true, blocks until the operation is complete </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="ab5b4d1b6dc55f7d3f640793b822d2cb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5b4d1b6dc55f7d3f640793b822d2cb4">&#9670;&nbsp;</a></span>ipscale()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void math::clFTensor::ipscale </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::CommandQueue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blocking</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inplace Scale every element of the tensor by a factor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">factor</td><td>The factor to scale the matrix with </td></tr>
    <tr><td class="paramname">queue</td><td>The queue to use for this operation </td></tr>
    <tr><td class="paramname">blocking</td><td>True if the operation is blocking, false otherwise </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb198043705a658795940854fc76a2f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb198043705a658795940854fc76a2f2">&#9670;&nbsp;</a></span>reshape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void math::clFTensor::reshape </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>new_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>new_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>new_depth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reshapes the tensor to the given dimensions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_rows</td><td></td></tr>
    <tr><td class="paramname">new_cols</td><td></td></tr>
    <tr><td class="paramname">new_depth</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a215201957ad7dae884cc2bea931c4bbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a215201957ad7dae884cc2bea931c4bbb">&#9670;&nbsp;</a></span>shallowCopy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmath_1_1cl_f_tensor.html">clFTensor</a> math::clFTensor::shallowCopy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a shallow copy of this tensor, meaning that the new tensor shares the same data. Any changes to the data of the new tensor will also affect the data of this tensor. </p>
<dl class="section return"><dt>Returns</dt><dd>A shallow copy of this tensor </dd></dl>

</div>
</div>
<a id="a827078394c2c42011e52e35e533cf56a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a827078394c2c42011e52e35e533cf56a">&#9670;&nbsp;</a></span>slice() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmath_1_1cl_f_tensor.html">clFTensor</a> math::clFTensor::slice </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Slice this tensor and return the tensor(rows, cols, begin:end) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>The first matrix of the slice </td></tr>
    <tr><td class="paramname">end</td><td>The last matrix of the slice, not included ([begin, end[) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A slice of this tensor </dd></dl>

</div>
</div>
<a id="ac0f97d8bba1b9ec670de2907608fca61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0f97d8bba1b9ec670de2907608fca61">&#9670;&nbsp;</a></span>slice() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classmath_1_1cl_f_tensor.html">clFTensor</a> &gt; math::clFTensor::slice </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ndiv</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Divides the tensor into multiple chunks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ndiv</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="aa8ef0a5164d96502e9b018f3163309e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8ef0a5164d96502e9b018f3163309e4">&#9670;&nbsp;</a></span>sub()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmath_1_1cl_f_tensor.html">clFTensor</a> math::clFTensor::sub </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmath_1_1cl_f_tensor.html">clFTensor</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::CommandQueue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blocking</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>C = A - alpha * B. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td></td></tr>
    <tr><td class="paramname">other</td><td></td></tr>
    <tr><td class="paramname">queue</td><td></td></tr>
    <tr><td class="paramname">blocking</td><td>If true, blocks until the operation is complete </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="ae6a0118b0b5a8d41bbac42cf23d16cfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6a0118b0b5a8d41bbac42cf23d16cfe">&#9670;&nbsp;</a></span>sumCollapse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmath_1_1cl_f_matrix.html">clFMatrix</a> math::clFTensor::sumCollapse </td>
          <td>(</td>
          <td class="paramtype">cl::CommandQueue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blocking</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sums the tensors along the z-axis, returning a single matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td></td></tr>
    <tr><td class="paramname">blocking</td><td>If true, blocks until the operation is complete </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/thukisdo/Desktop/Cours/projet21/include/math/<a class="el" href="cl_f_tensor_8hpp_source.html">clFTensor.hpp</a></li>
<li>/home/thukisdo/Desktop/Cours/projet21/src/math/clFTensor.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>math</b></li><li class="navelem"><a class="el" href="classmath_1_1cl_f_tensor.html">clFTensor</a></li>
    <li class="footer">Generated on Tue May 3 2022 15:14:50 for Kreps by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
