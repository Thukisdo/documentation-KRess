<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Kreps: control::InputSet Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Kreps
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
   <div id="projectbrief">Breast cancer detection through machine learning</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classcontrol_1_1_input_set.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classcontrol_1_1_input_set-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">control::InputSet Class Reference<span class="mlabels"><span class="mlabel">final</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Thread-safe set of samples that can be used to feed a neural network model Note that the samples are grouped in Tensors of heterogeneous size, which can be used for batched operations.  
 <a href="classcontrol_1_1_input_set.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_input_set_8hpp_source.html">InputSet.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ac303629a034428c00dade38b682f031a"><td class="memItemLeft" align="right" valign="top"><a id="ac303629a034428c00dade38b682f031a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>SampleIterator</b> = std::vector&lt; <a class="el" href="classcontrol_1_1_sample.html">Sample</a> &gt;::iterator</td></tr>
<tr class="separator:ac303629a034428c00dade38b682f031a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0485d18efa6f35a18cf2fbb18cd537b"><td class="memItemLeft" align="right" valign="top"><a id="ad0485d18efa6f35a18cf2fbb18cd537b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ConstSampleIterator</b> = std::vector&lt; <a class="el" href="classcontrol_1_1_sample.html">Sample</a> &gt;::const_iterator</td></tr>
<tr class="separator:ad0485d18efa6f35a18cf2fbb18cd537b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc02762b7df9769ce3af9fa42db9a12a"><td class="memItemLeft" align="right" valign="top"><a id="abc02762b7df9769ce3af9fa42db9a12a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>TensorIterator</b> = std::vector&lt; <a class="el" href="classmath_1_1cl_f_tensor.html">math::clFTensor</a> &gt;::iterator</td></tr>
<tr class="separator:abc02762b7df9769ce3af9fa42db9a12a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19a9f242df5e96713d5a9f26ea528a47"><td class="memItemLeft" align="right" valign="top"><a id="a19a9f242df5e96713d5a9f26ea528a47"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>TensorConstIterator</b> = std::vector&lt; <a class="el" href="classmath_1_1cl_f_tensor.html">math::clFTensor</a> &gt;::const_iterator</td></tr>
<tr class="separator:a19a9f242df5e96713d5a9f26ea528a47"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae4178b5d95caf8d4c0cdc4efd1cddbfc"><td class="memItemLeft" align="right" valign="top"><a id="ae4178b5d95caf8d4c0cdc4efd1cddbfc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>InputSet</b> (size_t input_width, size_t input_height)</td></tr>
<tr class="separator:ae4178b5d95caf8d4c0cdc4efd1cddbfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14e7bf40b065f5d6fbb06a32bd741076"><td class="memItemLeft" align="right" valign="top"><a id="a14e7bf40b065f5d6fbb06a32bd741076"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>InputSet</b> (const <a class="el" href="classcontrol_1_1_input_set.html">InputSet</a> &amp;)=delete</td></tr>
<tr class="separator:a14e7bf40b065f5d6fbb06a32bd741076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0bc355367ec9d4d33958449e182a20a"><td class="memItemLeft" align="right" valign="top"><a id="ab0bc355367ec9d4d33958449e182a20a"></a>
<a class="el" href="classcontrol_1_1_input_set.html">InputSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classcontrol_1_1_input_set.html">InputSet</a> &amp;)=delete</td></tr>
<tr class="separator:ab0bc355367ec9d4d33958449e182a20a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3400087a00bff84970a69accd3c1f556"><td class="memItemLeft" align="right" valign="top"><a id="a3400087a00bff84970a69accd3c1f556"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>InputSet</b> (<a class="el" href="classcontrol_1_1_input_set.html">InputSet</a> &amp;&amp;other) noexcept</td></tr>
<tr class="separator:a3400087a00bff84970a69accd3c1f556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4da94deaa57afcaaa069157dae52d63a"><td class="memItemLeft" align="right" valign="top"><a id="a4da94deaa57afcaaa069157dae52d63a"></a>
<a class="el" href="classcontrol_1_1_input_set.html">InputSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classcontrol_1_1_input_set.html">InputSet</a> &amp;&amp;other) noexcept</td></tr>
<tr class="separator:a4da94deaa57afcaaa069157dae52d63a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1df77d22de301b116d8fba766c4b8b94"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontrol_1_1_input_set.html#a1df77d22de301b116d8fba766c4b8b94">append</a> (<a class="el" href="classmath_1_1cl_f_tensor.html">math::clFTensor</a> &amp;&amp;tensor, const std::vector&lt; size_t &gt; &amp;ids, const std::vector&lt; long &gt; &amp;class_ids={})</td></tr>
<tr class="memdesc:a1df77d22de301b116d8fba766c4b8b94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append the given samples and their associated tensor to the input set. Samples are added at the end of the set.  <a href="classcontrol_1_1_input_set.html#a1df77d22de301b116d8fba766c4b8b94">More...</a><br /></td></tr>
<tr class="separator:a1df77d22de301b116d8fba766c4b8b94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bf76ed5dd9f349cabde840649b03334"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontrol_1_1_input_set.html#a2bf76ed5dd9f349cabde840649b03334">alterTensors</a> (size_t new_tensor_size)</td></tr>
<tr class="memdesc:a2bf76ed5dd9f349cabde840649b03334"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alter the tensors size and reorder the samples (Maintaining the same ordering) to match the new tensor size. This methods is not thread-safe, and invalidates all iterators. Note that this methods is costly, and should be used with care.  <a href="classcontrol_1_1_input_set.html#a2bf76ed5dd9f349cabde840649b03334">More...</a><br /></td></tr>
<tr class="separator:a2bf76ed5dd9f349cabde840649b03334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a498f3ad8d4b3400b8a12db2b11c3e03c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontrol_1_1_input_set.html#a498f3ad8d4b3400b8a12db2b11c3e03c">removeTensors</a> (size_t start, size_t end)</td></tr>
<tr class="memdesc:a498f3ad8d4b3400b8a12db2b11c3e03c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove tensors in [start, end[. This operation is thread-safe, but invalidates any iterators.  <a href="classcontrol_1_1_input_set.html#a498f3ad8d4b3400b8a12db2b11c3e03c">More...</a><br /></td></tr>
<tr class="separator:a498f3ad8d4b3400b8a12db2b11c3e03c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8a20149c5ffd00395153649c8c7fe1c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontrol_1_1_input_set.html#ad8a20149c5ffd00395153649c8c7fe1c">shuffle</a> (size_t random_seed)</td></tr>
<tr class="memdesc:ad8a20149c5ffd00395153649c8c7fe1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shuffle the samples in the set. This operation is thread-safe, but invalidates any iterators.  <a href="classcontrol_1_1_input_set.html#ad8a20149c5ffd00395153649c8c7fe1c">More...</a><br /></td></tr>
<tr class="separator:ad8a20149c5ffd00395153649c8c7fe1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cd9f34116c6792f02e57d8ce0de82d0"><td class="memItemLeft" align="right" valign="top"><a id="a5cd9f34116c6792f02e57d8ce0de82d0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontrol_1_1_input_set.html#a5cd9f34116c6792f02e57d8ce0de82d0">shuffle</a> ()</td></tr>
<tr class="memdesc:a5cd9f34116c6792f02e57d8ce0de82d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shuffle the samples in the set using a random seed. This operation is thread-safe, but invalidates any iterators. <br /></td></tr>
<tr class="separator:a5cd9f34116c6792f02e57d8ce0de82d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a846cb0b720d2eb9e2a7d677c1d8038dc"><td class="memItemLeft" align="right" valign="top"><a id="a846cb0b720d2eb9e2a7d677c1d8038dc"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>getSize</b> () const</td></tr>
<tr class="separator:a846cb0b720d2eb9e2a7d677c1d8038dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affd089b55364cd7753569c146f9360dd"><td class="memItemLeft" align="right" valign="top"><a id="affd089b55364cd7753569c146f9360dd"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>getInputWidth</b> () const</td></tr>
<tr class="separator:affd089b55364cd7753569c146f9360dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a779011229a7c5841d58df9d3d242a83c"><td class="memItemLeft" align="right" valign="top"><a id="a779011229a7c5841d58df9d3d242a83c"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>getInputHeight</b> () const</td></tr>
<tr class="separator:a779011229a7c5841d58df9d3d242a83c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bf2695cd149c8f6f62553779be0f2c7"><td class="memItemLeft" align="right" valign="top"><a id="a7bf2695cd149c8f6f62553779be0f2c7"></a>
<a class="el" href="classcontrol_1_1_sample.html">Sample</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator[]</b> (size_t index)</td></tr>
<tr class="separator:a7bf2695cd149c8f6f62553779be0f2c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a865706b5ecff52d9718a1939ce95af07"><td class="memItemLeft" align="right" valign="top"><a id="a865706b5ecff52d9718a1939ce95af07"></a>
const <a class="el" href="classcontrol_1_1_sample.html">Sample</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator[]</b> (size_t index) const</td></tr>
<tr class="separator:a865706b5ecff52d9718a1939ce95af07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c42c409a37b165e66a18e44da17bc08"><td class="memItemLeft" align="right" valign="top"><a id="a5c42c409a37b165e66a18e44da17bc08"></a>
SampleIterator&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> ()</td></tr>
<tr class="separator:a5c42c409a37b165e66a18e44da17bc08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2e6c3b17178094d6c1c0f54cd5a8385"><td class="memItemLeft" align="right" valign="top"><a id="af2e6c3b17178094d6c1c0f54cd5a8385"></a>
ConstSampleIterator&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> () const</td></tr>
<tr class="separator:af2e6c3b17178094d6c1c0f54cd5a8385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a178130bf09423ee0614f5c38c5155df8"><td class="memItemLeft" align="right" valign="top"><a id="a178130bf09423ee0614f5c38c5155df8"></a>
SampleIterator&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> ()</td></tr>
<tr class="separator:a178130bf09423ee0614f5c38c5155df8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af430a9f0b0963d1d016e99f4beda94c9"><td class="memItemLeft" align="right" valign="top"><a id="af430a9f0b0963d1d016e99f4beda94c9"></a>
ConstSampleIterator&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> () const</td></tr>
<tr class="separator:af430a9f0b0963d1d016e99f4beda94c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a194f5352786903a7b618a328eb6b8e23"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmath_1_1cl_f_tensor.html">math::clFTensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontrol_1_1_input_set.html#a194f5352786903a7b618a328eb6b8e23">getTensor</a> (size_t index) const</td></tr>
<tr class="memdesc:a194f5352786903a7b618a328eb6b8e23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the tensor at the given index.  <a href="classcontrol_1_1_input_set.html#a194f5352786903a7b618a328eb6b8e23">More...</a><br /></td></tr>
<tr class="separator:a194f5352786903a7b618a328eb6b8e23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e91bac954e861357807a384af2f6a65"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontrol_1_1_input_set.html#a8e91bac954e861357807a384af2f6a65">getClassOf</a> (size_t global_index) const</td></tr>
<tr class="memdesc:a8e91bac954e861357807a384af2f6a65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the class id of the sample at the given index.  <a href="classcontrol_1_1_input_set.html#a8e91bac954e861357807a384af2f6a65">More...</a><br /></td></tr>
<tr class="separator:a8e91bac954e861357807a384af2f6a65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03948c0f56cd0a8a85f2b060793ad8b6"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontrol_1_1_input_set.html#a03948c0f56cd0a8a85f2b060793ad8b6">getClassCount</a> () const</td></tr>
<tr class="memdesc:a03948c0f56cd0a8a85f2b060793ad8b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of classes.  <a href="classcontrol_1_1_input_set.html#a03948c0f56cd0a8a85f2b060793ad8b6">More...</a><br /></td></tr>
<tr class="separator:a03948c0f56cd0a8a85f2b060793ad8b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac98df36e71c2fa52a2a562d0808131ef"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontrol_1_1_input_set.html#ac98df36e71c2fa52a2a562d0808131ef">getTensorCount</a> () const</td></tr>
<tr class="memdesc:ac98df36e71c2fa52a2a562d0808131ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of tensors contained in this set Use getSize() to get the number of samples.  <a href="classcontrol_1_1_input_set.html#ac98df36e71c2fa52a2a562d0808131ef">More...</a><br /></td></tr>
<tr class="separator:ac98df36e71c2fa52a2a562d0808131ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73ba7ed3aaca1c5bab9a6699ed238d9a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmath_1_1cl_f_tensor.html">math::clFTensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontrol_1_1_input_set.html#a73ba7ed3aaca1c5bab9a6699ed238d9a">getTensor</a> (size_t index)</td></tr>
<tr class="memdesc:a73ba7ed3aaca1c5bab9a6699ed238d9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the tensor at the given index.  <a href="classcontrol_1_1_input_set.html#a73ba7ed3aaca1c5bab9a6699ed238d9a">More...</a><br /></td></tr>
<tr class="separator:a73ba7ed3aaca1c5bab9a6699ed238d9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafe28d3a32e88d712825b500f9997c9e"><td class="memItemLeft" align="right" valign="top">TensorIterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontrol_1_1_input_set.html#aafe28d3a32e88d712825b500f9997c9e">beginTensor</a> ()</td></tr>
<tr class="memdesc:aafe28d3a32e88d712825b500f9997c9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an iterator to the tensors contained in this set.  <a href="classcontrol_1_1_input_set.html#aafe28d3a32e88d712825b500f9997c9e">More...</a><br /></td></tr>
<tr class="separator:aafe28d3a32e88d712825b500f9997c9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2ef65548a823ba8c73d3153f72d3fb8"><td class="memItemLeft" align="right" valign="top"><a id="ae2ef65548a823ba8c73d3153f72d3fb8"></a>
TensorConstIterator&#160;</td><td class="memItemRight" valign="bottom"><b>beginTensor</b> () const</td></tr>
<tr class="separator:ae2ef65548a823ba8c73d3153f72d3fb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3229e9a95a2605b8a3e857a567f5ea1e"><td class="memItemLeft" align="right" valign="top">TensorIterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontrol_1_1_input_set.html#a3229e9a95a2605b8a3e857a567f5ea1e">endTensor</a> ()</td></tr>
<tr class="memdesc:a3229e9a95a2605b8a3e857a567f5ea1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an iterator to the end of the tensors contained in this set.  <a href="classcontrol_1_1_input_set.html#a3229e9a95a2605b8a3e857a567f5ea1e">More...</a><br /></td></tr>
<tr class="separator:a3229e9a95a2605b8a3e857a567f5ea1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaa1ee2088ec7516fed9c567f0b0c7d5"><td class="memItemLeft" align="right" valign="top"><a id="aaaa1ee2088ec7516fed9c567f0b0c7d5"></a>
TensorConstIterator&#160;</td><td class="memItemRight" valign="bottom"><b>endTensor</b> () const</td></tr>
<tr class="separator:aaaa1ee2088ec7516fed9c567f0b0c7d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e0057bf718e30634cba108bc623ca1d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classmath_1_1cl_f_tensor.html">math::clFTensor</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontrol_1_1_input_set.html#a6e0057bf718e30634cba108bc623ca1d">getTensors</a> ()</td></tr>
<tr class="memdesc:a6e0057bf718e30634cba108bc623ca1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the vector containing all the tensors.  <a href="classcontrol_1_1_input_set.html#a6e0057bf718e30634cba108bc623ca1d">More...</a><br /></td></tr>
<tr class="separator:a6e0057bf718e30634cba108bc623ca1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93f1384bf1e0a970d29902f2676c072f"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classmath_1_1cl_f_tensor.html">math::clFTensor</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontrol_1_1_input_set.html#a93f1384bf1e0a970d29902f2676c072f">getTensors</a> () const</td></tr>
<tr class="memdesc:a93f1384bf1e0a970d29902f2676c072f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the vector containing all the tensors.  <a href="classcontrol_1_1_input_set.html#a93f1384bf1e0a970d29902f2676c072f">More...</a><br /></td></tr>
<tr class="separator:a93f1384bf1e0a970d29902f2676c072f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a718ed5168d3c47dfdeaebd89efe0b3b5"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontrol_1_1_input_set.html#a718ed5168d3c47dfdeaebd89efe0b3b5">getClasses</a> ()</td></tr>
<tr class="memdesc:a718ed5168d3c47dfdeaebd89efe0b3b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the class id of the sample at the given index.  <a href="classcontrol_1_1_input_set.html#a718ed5168d3c47dfdeaebd89efe0b3b5">More...</a><br /></td></tr>
<tr class="separator:a718ed5168d3c47dfdeaebd89efe0b3b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae16b6717651c1e82339aef5df5db278a"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontrol_1_1_input_set.html#ae16b6717651c1e82339aef5df5db278a">getClasses</a> () const</td></tr>
<tr class="memdesc:ae16b6717651c1e82339aef5df5db278a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the class id of the sample at the given index.  <a href="classcontrol_1_1_input_set.html#ae16b6717651c1e82339aef5df5db278a">More...</a><br /></td></tr>
<tr class="separator:ae16b6717651c1e82339aef5df5db278a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa44d4a8b336350606b22d31b16bf1ab5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontrol_1_1_input_set.html#aa44d4a8b336350606b22d31b16bf1ab5">updateClasses</a> (std::vector&lt; std::string &gt; classes)</td></tr>
<tr class="memdesc:aa44d4a8b336350606b22d31b16bf1ab5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the classes of the samples in the input set. Note that this method only update the names of the classes, and doesn't handle the case where there are fewer classes than referenced by the samples.  <a href="classcontrol_1_1_input_set.html#aa44d4a8b336350606b22d31b16bf1ab5">More...</a><br /></td></tr>
<tr class="separator:aa44d4a8b336350606b22d31b16bf1ab5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Thread-safe set of samples that can be used to feed a neural network model Note that the samples are grouped in Tensors of heterogeneous size, which can be used for batched operations. </p>
<p>Does not support removing random samples from the set (Really complex operation since this would require tensors to be rearranged, and barely needed). However, supports removal of entire tensors. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a2bf76ed5dd9f349cabde840649b03334"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bf76ed5dd9f349cabde840649b03334">&#9670;&nbsp;</a></span>alterTensors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void control::InputSet::alterTensors </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>new_tensor_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alter the tensors size and reorder the samples (Maintaining the same ordering) to match the new tensor size. This methods is not thread-safe, and invalidates all iterators. Note that this methods is costly, and should be used with care. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_tensor_size</td><td>The new size of the tensors. If the tensor size is not a multiple of the number of samples, the last tensor will be truncated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1df77d22de301b116d8fba766c4b8b94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1df77d22de301b116d8fba766c4b8b94">&#9670;&nbsp;</a></span>append()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void control::InputSet::append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmath_1_1cl_f_tensor.html">math::clFTensor</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; long &gt; &amp;&#160;</td>
          <td class="paramname"><em>class_ids</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append the given samples and their associated tensor to the input set. Samples are added at the end of the set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor</td><td>The tensor containing the samples </td></tr>
    <tr><td class="paramname">ids</td><td>A vector containing the ids of the samples to append </td></tr>
    <tr><td class="paramname">class_ids</td><td>A vector containing the class ids of the samples to append. If the size of this vector is smaller than the size of the ids vector, the class id is ignored. This allow one to create an <a class="el" href="classcontrol_1_1_input_set.html" title="Thread-safe set of samples that can be used to feed a neural network model Note that the samples are ...">InputSet</a> where the classes are not known </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aafe28d3a32e88d712825b500f9997c9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafe28d3a32e88d712825b500f9997c9e">&#9670;&nbsp;</a></span>beginTensor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TensorIterator control::InputSet::beginTensor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an iterator to the tensors contained in this set. </p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a3229e9a95a2605b8a3e857a567f5ea1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3229e9a95a2605b8a3e857a567f5ea1e">&#9670;&nbsp;</a></span>endTensor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TensorIterator control::InputSet::endTensor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an iterator to the end of the tensors contained in this set. </p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a03948c0f56cd0a8a85f2b060793ad8b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03948c0f56cd0a8a85f2b060793ad8b6">&#9670;&nbsp;</a></span>getClassCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t control::InputSet::getClassCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of classes. </p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a718ed5168d3c47dfdeaebd89efe0b3b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a718ed5168d3c47dfdeaebd89efe0b3b5">&#9670;&nbsp;</a></span>getClasses() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt;&amp; control::InputSet::getClasses </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the class id of the sample at the given index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">global_index</td><td>The index of the sample in the input set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The class id of the sample, -1 if it is undefined Throw on out of range </dd></dl>

</div>
</div>
<a id="ae16b6717651c1e82339aef5df5db278a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae16b6717651c1e82339aef5df5db278a">&#9670;&nbsp;</a></span>getClasses() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;std::string&gt;&amp; control::InputSet::getClasses </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the class id of the sample at the given index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">global_index</td><td>The index of the sample in the input set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The class id of the sample, -1 if it is undefined Throw on out of range </dd></dl>

</div>
</div>
<a id="a8e91bac954e861357807a384af2f6a65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e91bac954e861357807a384af2f6a65">&#9670;&nbsp;</a></span>getClassOf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long control::InputSet::getClassOf </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>global_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the class id of the sample at the given index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">global_index</td><td>The index of the sample in the input set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The class id of the sample, -1 if it is undefined Throw on out of range </dd></dl>

</div>
</div>
<a id="a73ba7ed3aaca1c5bab9a6699ed238d9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73ba7ed3aaca1c5bab9a6699ed238d9a">&#9670;&nbsp;</a></span>getTensor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmath_1_1cl_f_tensor.html">math::clFTensor</a>&amp; control::InputSet::getTensor </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the tensor at the given index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the tensor to return </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The tensor at the given index </dd></dl>

</div>
</div>
<a id="a194f5352786903a7b618a328eb6b8e23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a194f5352786903a7b618a328eb6b8e23">&#9670;&nbsp;</a></span>getTensor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classmath_1_1cl_f_tensor.html">math::clFTensor</a>&amp; control::InputSet::getTensor </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the tensor at the given index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the tensor to return </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The tensor at the given index </dd></dl>

</div>
</div>
<a id="ac98df36e71c2fa52a2a562d0808131ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac98df36e71c2fa52a2a562d0808131ef">&#9670;&nbsp;</a></span>getTensorCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t control::InputSet::getTensorCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of tensors contained in this set Use getSize() to get the number of samples. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of tensors </dd></dl>

</div>
</div>
<a id="a6e0057bf718e30634cba108bc623ca1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e0057bf718e30634cba108bc623ca1d">&#9670;&nbsp;</a></span>getTensors() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classmath_1_1cl_f_tensor.html">math::clFTensor</a>&gt;&amp; control::InputSet::getTensors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the vector containing all the tensors. </p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a93f1384bf1e0a970d29902f2676c072f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93f1384bf1e0a970d29902f2676c072f">&#9670;&nbsp;</a></span>getTensors() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classmath_1_1cl_f_tensor.html">math::clFTensor</a>&gt;&amp; control::InputSet::getTensors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the vector containing all the tensors. </p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a498f3ad8d4b3400b8a12db2b11c3e03c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a498f3ad8d4b3400b8a12db2b11c3e03c">&#9670;&nbsp;</a></span>removeTensors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void control::InputSet::removeTensors </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove tensors in [start, end[. This operation is thread-safe, but invalidates any iterators. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>The index of the first tensor to remove </td></tr>
    <tr><td class="paramname">end</td><td>The index of the last tensor (not included) to remove </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad8a20149c5ffd00395153649c8c7fe1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8a20149c5ffd00395153649c8c7fe1c">&#9670;&nbsp;</a></span>shuffle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void control::InputSet::shuffle </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>random_seed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shuffle the samples in the set. This operation is thread-safe, but invalidates any iterators. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">random_seed</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa44d4a8b336350606b22d31b16bf1ab5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa44d4a8b336350606b22d31b16bf1ab5">&#9670;&nbsp;</a></span>updateClasses()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void control::InputSet::updateClasses </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>classes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the classes of the samples in the input set. Note that this method only update the names of the classes, and doesn't handle the case where there are fewer classes than referenced by the samples. </p>
<p>TODO: Improve class / label handling </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">classes</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/thukisdo/Desktop/Cours/projet21/include/controlSystem/<a class="el" href="_input_set_8hpp_source.html">InputSet.hpp</a></li>
<li>/home/thukisdo/Desktop/Cours/projet21/src/controlSystem/InputSet.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacecontrol.html">control</a></li><li class="navelem"><a class="el" href="classcontrol_1_1_input_set.html">InputSet</a></li>
    <li class="footer">Generated on Tue May 3 2022 15:14:50 for Kreps by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
